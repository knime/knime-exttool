/*
 * ------------------------------------------------------------------------
 *
 *  Copyright (C) 2003 - 2010
 *  University of Konstanz, Germany and
 *  KNIME GmbH, Konstanz, Germany
 *  Website: http://www.knime.org; Email: contact@knime.org
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License, Version 3, as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses>.
 *
 *  Additional permission under GNU GPL version 3 section 7:
 *
 *  KNIME interoperates with ECLIPSE solely via ECLIPSE's plug-in APIs.
 *  Hence, KNIME and ECLIPSE are both independent programs and are not
 *  derived from each other. Should, however, the interpretation of the
 *  GNU GPL Version 3 ("License") under any applicable laws result in
 *  KNIME and ECLIPSE being a combined program, KNIME GMBH herewith grants
 *  you the additional permission to use and propagate KNIME together with
 *  ECLIPSE with only the license terms in place for ECLIPSE applying to
 *  ECLIPSE and the GNU GPL Version 3 applying for KNIME, provided the
 *  license terms of ECLIPSE themselves allow for the respective use and
 *  propagation of ECLIPSE together with KNIME.
 *
 *  Additional permission relating to nodes for KNIME that extend the Node
 *  Extension (and in particular that are based on subclasses of NodeModel,
 *  NodeDialog, and NodeView) and that only interoperate with KNIME through
 *  standard APIs ("Nodes"):
 *  Nodes are deemed to be separate and independent programs and to not be
 *  covered works.  Notwithstanding anything to the contrary in the
 *  License, the License does not apply to Nodes, you are not required to
 *  license Nodes under the License, and you are granted a license to
 *  prepare and propagate Nodes, in each case even if such Nodes are
 *  propagated with or for interoperation with KNIME. The owner of a Node
 *  may freely choose the license terms applicable to such Node, including
 *  when such Node is propagated with or for interoperation with KNIME.
 * ------------------------------------------------------------------------
 *
 * History
 *   Jan 18, 2010 (wiswedel): created
 */
package org.knime.exttool.node.base;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.File;
import java.util.Enumeration;

import javax.swing.AbstractButton;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JSeparator;
import javax.swing.JTextField;

import org.knime.core.data.DataTableSpec;
import org.knime.core.node.InvalidSettingsException;
import org.knime.core.node.NodeSettings;
import org.knime.core.node.NotConfigurableException;
import org.knime.exttool.filetype.AbstractFileTypeFactory;
import org.knime.exttool.node.base.ExttoolSettings.PathAndTypeConfiguration;

/**
 * @author Bernd Wiswedel, KNIME.com, Zurich, Switzerland
 */
public class OutputFilePanel extends JPanel {

    private final ExttoolCustomizer m_exttoolCustomizer;

    private final ButtonGroup m_outputFileTypeButtonGroup;
    private final JCheckBox m_autoGeneratedFileNameChecker;
    private final JTextField[] m_outputFileFields;
    private final JButton[] m_outputFileBrowseButtons;
    private File m_lastDirectory;


    /**
     *
     */
    public OutputFilePanel(final ExttoolCustomizer customizer) {
        super(new GridBagLayout());
        m_exttoolCustomizer = customizer;
        m_outputFileTypeButtonGroup = new ButtonGroup();
        m_autoGeneratedFileNameChecker =
            new JCheckBox("Generate unique file name on execute");
        m_outputFileFields = new JTextField[customizer.getNrOutputs()];
        m_outputFileBrowseButtons = new JButton[m_outputFileFields.length];
        for (int i = 0; i < m_outputFileFields.length; i++) {
            final JTextField textField = new JTextField(20);
            m_outputFileFields[i] = textField;
            m_outputFileBrowseButtons[i] = new JButton("Browse...");
            m_outputFileBrowseButtons[i].addActionListener(
                    new ActionListener() {
                private final JFileChooser m_chooser = new JFileChooser();

                /** {@inheritDoc} */
                @Override
                public void actionPerformed(final ActionEvent e) {
                    String old = textField.getText();
                    if (old != null && old.length() > 0) {
                        File parent = new File(old).getParentFile();
                        if (parent.isDirectory()) {
                            m_chooser.setCurrentDirectory(parent);
                        }
                    } else if (m_lastDirectory != null) {
                        m_chooser.setCurrentDirectory(m_lastDirectory);
                    }
                    int exit = m_chooser.showDialog(
                            OutputFilePanel.this, "Select");
                    if (exit == JFileChooser.APPROVE_OPTION) {
                        File selFile = m_chooser.getSelectedFile();
                        if (selFile != null) {
                            m_lastDirectory = selFile.getParentFile();
                            textField.setText(selFile.getAbsolutePath());
                        }
                    }
                }
            });
        }

        m_autoGeneratedFileNameChecker.addItemListener(new ItemListener() {
            /** {@inheritDoc} */
            public void itemStateChanged(final ItemEvent e) {
                boolean selected = m_autoGeneratedFileNameChecker.isSelected();
                for (int i = 0; i < m_outputFileFields.length; i++) {
                    m_outputFileFields[i].setEnabled(!selected);
                    m_outputFileBrowseButtons[i].setEnabled(!selected);
                }
            }
        });
        m_autoGeneratedFileNameChecker.doClick();
    }

    protected void initLayout() {
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.anchor = GridBagConstraints.NORTHWEST;
        gbc.insets = new Insets(5, 5, 5, 5);

        StringBuilder helpText = new StringBuilder("<html><body>");
        helpText.append("Input file to the executable. The file is written ");
        helpText.append("by KNIME <br />");
        helpText.append("prior execution and passed to the executable.");
        JLabel label = new JLabel(helpText.toString());
        add(label, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        add(new JSeparator(), gbc);
        gbc.fill = GridBagConstraints.NONE;

        if (m_exttoolCustomizer.isShowOutputTypeSelection()) {
            JPanel typePanel = new JPanel(new GridLayout(0, 4));
            typePanel.setBorder(
                    BorderFactory.createTitledBorder("Output File Type"));
            JRadioButton first = null;
            for (AbstractFileTypeFactory t
                    : AbstractFileTypeFactory.getReadFactories()) {
                JRadioButton button = new JRadioButton(t.getUserFriendlyName());
                button.setActionCommand(t.getClass().getName());
                if (first == null) {
                    first = button;
                }
                m_outputFileTypeButtonGroup.add(button);
                typePanel.add(button);
            }
            if (first != null) {
                first.doClick();
            }
            gbc.gridwidth = GridBagConstraints.REMAINDER;
            add(typePanel, gbc);
        }

        if (m_exttoolCustomizer.isShowPathToTempInputFile()) {
            add(m_autoGeneratedFileNameChecker, gbc);
            gbc.gridwidth = 1;
            for (int i = 0; i < m_outputFileFields.length; i++) {
                String name = "File Path" + ((m_outputFileFields.length > 1)
                        ? " (Port " + i + ")" : "");
                add(new JLabel(name), gbc);
                add(m_outputFileFields[i], gbc);

                gbc.gridwidth = GridBagConstraints.REMAINDER;
                add(m_outputFileBrowseButtons[i], gbc);
            }
        }

        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        add(new JSeparator(), gbc);
        gbc.fill = GridBagConstraints.NONE;
    }

    protected void loadSettingsFrom(final ExttoolSettings settings,
            final DataTableSpec[] inputSpecs) throws NotConfigurableException {
        final int nrOutputs = m_exttoolCustomizer.getNrOutputs();
        for (int i = 0; i < nrOutputs; i++) {
            PathAndTypeConfiguration config = settings.getOutputConfig(i);
            String path = config.getPath();
            String type = config.getType();
            m_autoGeneratedFileNameChecker.setEnabled(path != null);
            m_outputFileFields[i].setText(path);
            for (Enumeration<AbstractButton> enu = m_outputFileTypeButtonGroup
                    .getElements(); enu.hasMoreElements();) {
                AbstractButton button = enu.nextElement();
                if (button.getActionCommand().equals(type)) {
                    button.doClick();
                }
            }
        }
    }

    protected void saveSettingsTo(final ExttoolSettings settings)
        throws InvalidSettingsException {
        final int nrOutputs = m_exttoolCustomizer.getNrOutputs();
        for (int o = 0; o < nrOutputs; o++) {
            String path = m_autoGeneratedFileNameChecker.isSelected()
                ? null : m_outputFileFields[o].getText();
            String type =
                m_outputFileTypeButtonGroup.getSelection().getActionCommand();
            NodeSettings outputSettings = null;
            outputSettings = new NodeSettings("output");
            AbstractFileTypeFactory fac = AbstractFileTypeFactory.get(type);
            fac.createNewReadInstance().saveSettings(outputSettings);

            PathAndTypeConfiguration config =
                new PathAndTypeConfiguration(false);
            config.setPath(path);
            config.setType(type);
            config.setTypeSettings(outputSettings);
            settings.setOutputConfig(o, config);
        }
    }

    public static void main(final String[] args) {
        JFrame frame = new JFrame("Test " + OutputFilePanel.class);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        OutputFilePanel panel = new OutputFilePanel(new ExttoolCustomizer());
        panel.initLayout();
        frame.getContentPane().add(panel);
        frame.pack();
        frame.setVisible(true);
    }


}
